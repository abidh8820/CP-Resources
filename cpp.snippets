priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

snippet t--
int t;
cin >> t;

while(t--){
	${0}
}
endsnippet

snippet segtree


typedef long long LL;
const int N = 1 << 18;

LL tree[N * 4], prob[N * 4], a[N];

void build(int u, int l, int r) {
	if (l == r) {
		tree[u] = a[l];
		return;
	}
	int mid = (l + r) / 2;
	build(u * 2, l, mid);
	build(u * 2 + 1, mid + 1, r);
	tree[u] = min(tree[u * 2], tree[u * 2 + 1]);
}

void propagate(int u) {
	prob[u * 2] += prob[u];
	tree[u * 2] += prob[u];
	prob[u * 2 + 1] += prob[u];
	tree[u * 2 + 1] += prob[u];
	prob[u] = 0;
}

void update(int u, int l, int r, int i, int j, int val) {
	if (r < i || l > j) return;
	if (l >= i && r <= j) {
		prob[u] += val;
		tree[u] += val;
		return;
	}
	propagate(u);int mid = (l + r) / 2;
	update(u * 2, l, mid, i, j, val);
	update(u * 2 + 1, mid + 1, r, i, j, val);
	tree[u] = min(tree[u * 2], tree[u * 2 + 1]);
}

LL query(int u, int l, int r, int i, int j) {
	if (l > j || r < i) return 1e18;
	if (l >= i && r <= j) return tree[u];
	propagate(u);
	int mid = (l + r) / 2;
	return min(query(u * 2, l, mid, i, j), query(u * 2 + 1, mid + 1, r, i, j));
}

endsnippet

snippet combi
LL fac[N], invfac[N];

void pre() {
	fac[0] = 1;
	for (int i = 1; i < N; i++) fac[i] = (fac[i - 1] * i) % M;
	invfac[N - 1] = BM(fac[N - 1], M - 2);
	for (int i = N - 2; i >= 0; i--) invfac[i] = (invfac[i + 1] * (i + 1)) % M;
}
endsnippet

snippet bm
LL BM(LL a, LL p) {
	if (p == 0) return 1;
	if (p == 1) return a;
	if (p & 1) return (a * BM(a, p - 1)) % M;
	LL f = BM(a, p / 2);
	return (f * f) % M;
}
endsnippet

snippet mod
const int M = 1e9 + 7;
endsnippet

snippet maxn
const int N = 1e${1:6}+7;
endsnippet

snippet LL
typedef long long LL;
endsnippet
snippet matexpo
struct Mat {
	long long a[2][2] = {{0, 0}, {0, 0}};
	Mat operator*(const Mat& other) {
		Mat res;
		for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
				for (int k = 0; k < 2; k++) {
					res.a[i][k] = (res.a[i][k] + (a[i][j] * other.a[j][k]))%M;
			}
		return res;
	}
};

Mat bm(Mat a, long long p) {
	if (p == 1) return a;
	if (p & 1) return a * (bm(a, p - 1));
	Mat tepm = bm(a, p / 2);
	return (tepm * tepm);
}
endsnippet

snippet kmp
int prefixFunction(const string& s) {
	int n = s.size();
	vector<int> pi(n);
	for (int i = 1; i < n; i++) {
		int j = pi[i - 1];
		while (j > 0 && s[j] != s[i]) j = pi[j - 1];
		if (s[j] == s[i]) j++;
		pi[i] = j;
	}
	return pi[n-1];
}
endsnippet
snippet dsu
const int N = 1e5+7;
int par[N];
void init() {
	for (int i=0; i<N; i++)     par[i] = i;
}

int find(int u) {
	if (u==par[u])  return u;
	return par[u] = find(par[u]);
}
void merge(int u, int v) {
	par[find(u)] = find(v);
}
endsnippet

snippet sieve
const int N = 1e6+7;

bool flag[N];
vector<int> primes;

void sieve() {
	for(int i=2; i<N; i++){
		if(!flag[i]){
			for(int j=2*i; j<N; j+=i) flag[j] = 1;
			primes.push_back(i);
		}
	}
}
endsnippet

snippet lamda
auto evaluate = [&](LL val) {
};
endsnippet

snippet point
const double PI = acos(-1);
struct Point {
	double x, y;
	Point(double x = 0, double y = 0) : x(x), y(y) {}

	Point operator + (const Point& u) const { return Point(x + u.x, y + u.y); }
	Point operator - (const Point& u) const { return Point(x - u.x, y - u.y); }
	Point operator * (const long long u) const { return Point(x * u, y * u); }
	Point operator * (const double u) const { return Point(x * u, y * u); }
	Point operator / (const double u) const { return Point(x / u, y / u); }
};

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double length(Point a) { return sqrt(dot(a, a)); }
double sqLength(Point a) { return dot(a, a); }
double distance(Point a, Point b) {return length(a-b);}
double angle(Point u) { return atan2(u.y, u.x); }
endsnippet
###########################################################################
#                            TextMate Snippets                            #
###########################################################################
# vim:ft=snippets:
