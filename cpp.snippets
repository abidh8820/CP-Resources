priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

snippet file
freopen("in","r",stdin);
freopen("out","w",stdout);
endsnippet

snippet t--
int t;
cin >> t;

while(t--){
	${0}
}
endsnippet

snippet pii
typedef pair<int,int> pii;
endsnippet

snippet segtree


typedef long long LL;
const int N = 1 << 18;

LL tree[N * 4], prob[N * 4], a[N];

void build(int u, int l, int r) {
	if (l == r) {
		tree[u] = a[l];
		return;
	}
	int mid = (l + r) / 2;
	build(u * 2, l, mid);
	build(u * 2 + 1, mid + 1, r);
	tree[u] = min(tree[u * 2], tree[u * 2 + 1]);
}

void propagate(int u) {
	prob[u * 2] += prob[u];
	tree[u * 2] += prob[u];
	prob[u * 2 + 1] += prob[u];
	tree[u * 2 + 1] += prob[u];
	prob[u] = 0;
}

void update(int u, int l, int r, int i, int j, int val) {
	if (r < i || l > j) return;
	if (l >= i && r <= j) {
		prob[u] += val;
		tree[u] += val;
		return;
	}
	propagate(u);int mid = (l + r) / 2;
	update(u * 2, l, mid, i, j, val);
	update(u * 2 + 1, mid + 1, r, i, j, val);
	tree[u] = min(tree[u * 2], tree[u * 2 + 1]);
}

LL query(int u, int l, int r, int i, int j) {
	if (l > j || r < i) return 1e18;
	if (l >= i && r <= j) return tree[u];
	propagate(u);
	int mid = (l + r) / 2;
	return min(query(u * 2, l, mid, i, j), query(u * 2 + 1, mid + 1, r, i, j));
}

endsnippet

snippet combi
LL fac[N], invfac[N];

void pre() {
	fac[0] = 1;
	for (int i = 1; i < N; i++) fac[i] = (fac[i - 1] * i) % M;
	invfac[N - 1] = BM(fac[N - 1], M - 2);
	for (int i = N - 2; i >= 0; i--) invfac[i] = (invfac[i + 1] * (i + 1)) % M;
}

endsnippet

snippet bm
LL BM(LL a, LL p) {
	if (p == 0) return 1;
	if (p == 1) return a;
	if (p & 1) return (a * BM(a, p - 1)) % M;
	LL f = BM(a, p / 2);
	return (f * f) % M;
}
endsnippet

snippet mod
const int M = 1e9 + 7;
endsnippet

snippet maxn
const int N = 1e${1:6}+7;
endsnippet

snippet LL
typedef long long LL;
endsnippet

snippet matexpo
const int N = 1e6 + 7;
const int M = 1e9 + 7;

struct Mat {
	long long a[2][2];
	Mat() {
		for (int i = 0; i < 2; i++)
		for (int j = 0; j < 2; j++) a[i][j] = 0;
	}
	Mat(int x) { a[0][0] = a[1][1] = 1; }

	Mat operator*(const Mat& other) {
		Mat res;
		for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
				for (int k = 0; k < 2; k++) {
					res.a[i][k] = (res.a[i][k] + (a[i][j] * other.a[j][k]))%M;
			}
		return res;
	}
};

Mat bm(Mat a, long long p) {
	if(p==0) return Mat(1);
	if (p == 1) return a;
	if (p & 1) return a * (bm(a, p - 1));
	Mat tepm = bm(a, p / 2);
	return (tepm * tepm);
}
endsnippet

snippet kmp
int prefixFunction(const string& s) {
	int n = s.size();
	vector<int> pi(n);
	for (int i = 1; i < n; i++) {
		int j = pi[i - 1];
		while (j > 0 && s[j] != s[i]) j = pi[j - 1];
		if (s[j] == s[i]) j++;
		pi[i] = j;
	}
	return pi[n-1];
}
endsnippet
snippet dsu
const int N = 1e5+7;
int par[N];
void init() {
	for (int i=0; i<N; i++)     par[i] = i;
}

int find(int u) {
	if (u==par[u])  return u;
	return par[u] = find(par[u]);
}
void merge(int u, int v) {
	par[find(u)] = find(v);
}
endsnippet

snippet sieve
const int N = 1e6+7;

bool flag[N];
vector<int> primes;

void sieve() {
	for(int i=2; i<N; i++){
		if(!flag[i]){
			for(int j=2*i; j<N; j+=i) flag[j] = 1;
			primes.push_back(i);
		}
	}
}
endsnippet

snippet lamda
auto evaluate = [&](LL val) {
};
endsnippet

snippet point
template<typename T>
struct Point {
	T x, y;
	Point(T x = 0, T y = 0) : x(x), y(y) {}

	Point operator+(const Point &u) const { return Point(x + u.x, y + u.y); }
	Point operator-(const Point &u) const { return Point(x - u.x, y - u.y); }
	Point operator*(const long long u) const { return Point(x * u, y * u); }
	Point operator*(const double u) const { return Point(x * u, y * u); }
	Point operator/(const double u) const { return Point(x / u, y / u); }
	
	friend T dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
	friend T cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
	friend T length(Point a) { return sqrt(dot(a, a)); }
	friend T sqLength(Point a) { return dot(a, a); }
	friend T distance(Point a, Point b) {return length(a-b);}
	friend T angle(Point u) { return atan2(u.y, u.x); }
	friend istream& operator>>(istream &is, Point &p) {   return is >> p.x >> p.y;}
	friend ostream& operator<<(ostream &os, const Point &p) { return os << p.x << " " << p.y;}
};

int sgn(const long long& x) { return x >= 0 ? x ? 1 : 0 : -1; }

endsnippet

snippet segment
template <typename T>
struct Segment {
	Point<T> a, b;
	Segment(Point<T> a_, Point<T> b_) { a = a_, b = b_; }

	friend bool parallel(Segment A, Segment B) { return cross(A.b - A.a, B.b - B.a) == 0; }
	friend bool colinear(Segment A, Segment B) { return cross(B.a - A.a, A.b - A.a) == 0; }

	friend bool intersect(Segment A, Segment B) {
		Point<T> p1 = A.a, p2 = A.b, p3 = B.a, p4 = B.b;
		int s1 = sgn(cross(p3 - p1, p2 - p1));
		int s2 = sgn(cross(p4 - p1, p2 - p1));
		int s3 = sgn(cross(p1 - p3, p4 - p3));
		int s4 = sgn(cross(p2 - p3, p4 - p3));

		if (s1 != s2 && s3 != s4) return true;
		if (!parallel(A,B) || !colinear(A,B)) return false;

		if (!(max(p1.x, p2.x) < min(p3.x, p4.x) ||  max(p1.y, p2.y) < min(p3.y, p4.y)) &&
			!(max(p3.x, p4.x) < min(p1.x, p2.x) ||    max(p3.y, p4.y) < min(p1.y, p2.y)))
		return true;
	return false;
	}
};
endsnippet

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
# vim:ft=snippets:
